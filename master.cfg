# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# ex: set syntax=python:
# vim: ft=python
# NIpy buildBOT Master Instance config
#
# [ TODO ]      (in no particular order)
# - combine multiple steps into one (if possible)
# - rename steps to be more concise and informative
# - generate numpy version based templates
# - what's up with the buildout not using ~/.buildout/default.cfg and not caching
#       * we may need to set some properties for this to work
# - install more versions of python on the slaves
# - have slaves report back their configuration (so we have them doing the right builders)
# - if possible, forcebuild every builder on a particular slave (to check that it can)
# - hookup with git post-commit hooks (instead of relying on poller)

""" A brief tour of buildbot

To remind myself

A ChangeSource looks for Changes.

In our case we are using GitPoller ChangeSource to look for changes in our git
repositories.

When ChangeSource finds changes, it broadcasts them to all Schedulers.  Each
Scheduler must decide if it wants to react to a Change.  It generally does this
by filtering changes to select changes it will act on.

We use SingleBranchSchedulers for this.  These obviously respond only to
changes in one branch of a repository. .schedulers() outputs list of
SingleBranchSchedulers with each linked to builders corresponding to each
branch if there are more than one.

A BuildSet is the association of (information about what changes need to be
tested) and (Builders on which to test)

If a Scheduler selects changes for action, it sends BuildSets to the system
(the BuildMaster).  Therefore, a Scheduler needs to know its Builders. It gets
these by name (string).

For each BuildSet, the (changes to be tested) are sent to each Builder.  Each
of these requests is BuildRequest.

A Builder accepts a BuildRequest and runs it on a BuildSlave.  It does this by
using its own BuildFactory instance to make Builds.

A Builder can have more than one associated BuildSlave.  In this case each
associated BuildSlave is assumed to produce identical results, and the Builder
can therefore choose at whim which BuildSlave to use.

A Build has one or more Steps that should be run with a given (changes to be
tested).

One type of build Step is a Trigger, which activates a triggerable Scheduler,
which can react any way it likes, including sending further BuildSets.
"""

from os.path import join as pjoin

# This is convenient for splitting sh commands into lists
import shlex

# Buildbot objects
from buildbot.locks import MasterLock
from buildbot.buildslave import BuildSlave
from buildbot.changes.gitpoller import GitPoller
from buildbot.schedulers.filter import ChangeFilter
from buildbot.schedulers.forcesched import (ForceScheduler,
                                            FixedParameter,
                                            ChoiceStringParameter,
                                            StringParameter)
from buildbot.schedulers.basic import SingleBranchScheduler, AnyBranchScheduler
from buildbot.schedulers import timed
from buildbot.schedulers.triggerable import Triggerable
from buildbot.schedulers.trysched import Try_Jobdir
from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand, SetPropertyFromCommand
from buildbot.steps.transfer import FileDownload, DirectoryUpload
from buildbot.steps.trigger import Trigger
from buildbot.process.properties import Property, Interpolate
from buildbot.config import BuilderConfig

HTTP_SERVER_URL='https://nipy.bic.berkeley.edu/scipy_installers/'

# Directory for cached downloads of files needed by buildbots
HTTP_CACHE_URL = HTTP_SERVER_URL + 'buildbot-files/'

# Canonical URL for ez_setup
# https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py
# Cached copy set by mb312 account crontab
EZ_SETUP_URL = HTTP_CACHE_URL + 'ez_setup.py'

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

"""
Load local setup from python module
Local setup is:

* master_url : str; URL that the master serves on.  Putting this in the setup
  allows us to run master on another machine for debugging
* slave_portnum : int; slave port number, as above
* slave_passes : dict; key, value pairs of (slave name, password) giving slave
  names and slave password.

Don't store local_setup in version control with real passwords !  Use
secret_passwords.py instead, and don't put in version control.
"""
import local_setup
reload(local_setup) # so buildbot reconfig refreshes these parameters

# Check parameters in setup
for attr_name in ('slave_passes', 'master_url', 'slave_port'):
    assert hasattr(local_setup, attr_name)

# Fetch any secret passwords.  We're using this trick so it is harder to save
# the secret passwords accidentally into version control
try:
    import secret_passwords
    reload(secret_passwords)
except ImportError:
    pass
else:
    for slavename, password in secret_passwords.slave_passes.items():
        local_setup.slave_passes[slavename] = password

# Check that slave names are unique
if len(set(local_setup.slave_passes)) != len(local_setup.slave_passes):
    raise ValueError('Slave names must be unique')

####### BUILDSLAVES

# Slave groups
linux_64_slaves = ['tom-standard']
linux_32_slaves = ['bongoslave']
debian_ppc_slaves = ['debian-ppc-32']
sparc_slaves_sid = ['nd-bb-slave-sparc-sid']
sparc_slaves_wheezy = ['nd-bb-slave-sparc-wheezy']
sparc_slaves = ['nd-bb-slave-sparc']
osx_leopard_ppc_slaves = ['osx-10.5-ppc']
osx_tiger_ppc_slaves = ['osx-mini']
osx_leopard_intel_slaves = ['osx-10.5']
osx_snowleopard_slaves = ['osx-10.6']
osx_lion_slaves = ['osx-10.7']
osx_mountainlion_slaves = ['osx-10.8']
win7_32_slaves = ['win7-32-mini']
win7_64_slaves = ['mike-win7-64']
arm_slaves = ['arm-raspberry-pi']
fedora_slaves = ['i20-fed19']
osx_wheel_slaves = ['osx-10.6-clean']

# Locks to prevent resource exhaustion which might need to be defined
# for some slaves.  It seems that locks need to be given to BuildSlave
# at __init__ time, so let's construct the mapping first: slave -> [locks]
# which are later used while initiating BuildSlave's
def add_lock(slave_locks, slavenames, lock, *accessargs):
    """Add a LockAccess's to a lock to the list of slaves
    """
    for name in slavenames:
        if not (name in slave_locks):
            slave_locks[name] = []
        slave_locks[name].append(lock.access(*accessargs))

slave_locks = {}

# vagus sparc box has only 4 CPUs, thus we should not run more than 4
# jobs in parallel
add_lock(slave_locks,
         sparc_slaves_sid + sparc_slaves_wheezy + sparc_slaves,
         MasterLock("vagus", maxCount=4), 'counting')

# wheel slave does awful things to /usr/local, should only run one job at a
# time
add_lock(slave_locks,
         osx_wheel_slaves,
         MasterLock("wheel-usr-local", maxCount=1), 'counting')

# These are working desktops, so throttle them to keep the machines calm
add_lock(slave_locks,
         ['tom-standard', 'osx-10.8'],
         MasterLock("working-desktops", maxCount=1), 'counting')

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
slaves = [BuildSlave(slave_name, slave_pass, locks=slave_locks.get(slave_name, None))
    for slave_name, slave_pass in local_setup.slave_passes.items()]

# slave names must be unique
c['slaves'] = slaves

# 'slavePortnum' defines the TCP port to listen on for connections from slaves.
# This must match the value configured into the buildslaves (with their
# --master option)
c['slavePortnum'] = local_setup.slave_port

def sanitize_branch_name(name):
    return name.replace('/', '+')

def is_one_default_branch(branches, branch):
    return (len(branches) < 2 and (branch in (None, 'master', 'HEAD')))

def get_branch_builder_name(builder, branches, branch=None):
    if branch is None or is_one_default_branch(branches, branch):
        return builder
    else:
        return '%s_%s' % (builder, sanitize_branch_name(branch))

# Helper functions and constants
class GithubBot(object):
    """ Class to make buildbot stuff based round a github repo
    """

    def __init__(self,
                 organization,
                 repo,
                 test_cmd,
                 doc_build_cmd=None,
                 built_doc_src=None,
                 easy_depends=(), # careful with easy_install and system packages
                 pip_depends=(),
                 # careful with easy_install and system packages
                 doc_easy_depends=(),
                 doc_pip_depends=('sphinx',),
                 src_subdir=None,
                 download_dir=None,
                 build_timeout=None,
                 test_env=None,
                 test_dir=None,
                 branches=["master"],
                 ):
        # using easy_install on packages that are already in
        # system-site-packages causes the system path to get promoted above the
        # virtualenv path, and usually causes a terrible mess.  so prefer pip
        # if at all possible.
        self.organization = organization
        self.repo = repo
        self.git_url = "git://github.com/%s/%s.git" % (organization, repo)
        self.test_cmd = test_cmd
        self.test_env = test_env
        self.test_dir = test_dir
        self.doc_build_cmd = doc_build_cmd
        self.built_doc_src = built_doc_src
        # Dependencies for install / test
        self.easy_depends = easy_depends # easy_install installs
        self.pip_depends = pip_depends # pip
        self.doc_easy_depends = doc_easy_depends # easy_installs for docs
        self.doc_pip_depends = doc_pip_depends # pip installs for docs
        self.src_subdir = src_subdir # Subdirectory containing source
        if download_dir is None:
            download_dir = '%s-dist' % repo
        self.download_dir = download_dir
        self.build_timeout = build_timeout
        self.branches = branches

    @property
    def project(self):
        return "%s" % (self.repo,)

    def poller(self, branches=None, interval=300):
        if branches is None:
            branches = self.branches
        return GitPoller(
            self.git_url,
            project=self.project,
            category=self.project,
            workdir = "%s-%s-%s" % (self.organization, self.repo, sanitize_branch_name('_'.join(branches))),
            branches=branches,
            pollinterval=interval)

    def _get_scheduler(self, branch_buildernames, branches, branch):
        # we need a closure to maintain the function comparing to the
        # actual target branch
        def _branch_fn(b):
            return lambda b_: b_==b
        branch_fn = _branch_fn(branch)
        return SingleBranchScheduler(
            name=get_branch_builder_name(self.project, branches, branch),
            change_filter=ChangeFilter(
                 repository=self.git_url,
                 project=self.project,
                 category=self.project,
                 branch_fn=branch_fn),
            treeStableTimer=None,
            builderNames=branch_buildernames)

    def schedulers(self, buildernames, branches=None):
        if isinstance(buildernames, basestring):
            buildernames = [buildernames]
        if branches is None:
            branches = self.branches
        # Create a separate scheduler per each branch linking it
        # to correspondingly named builders
        return [self._get_scheduler(
                      [get_branch_builder_name(n, branches, branch)
                       for n in buildernames],
                      branches, branch)
                for branch in branches]

    def nightly_scheduler(self,
                          buildernames,
                          name_suff,
                          hour = 2, minute = 23,
                          ifchanged=True,
                          branch='master',
                         ):
        """ Make a timed scheduler for this repo """
        if isinstance(buildernames, basestring):
            buildernames = [buildernames]
        name = "%s-%s-nightly-%s" % (self.organization, self.repo, name_suff)
        changefilter = ChangeFilter(repository=self.git_url,
                                    project=self.project,
                                    category=self.project)
        return timed.Nightly(name=name,
                branch=branch,
                builderNames=buildernames,
                change_filter=changefilter,
                hour=hour,
                minute=minute,
                onlyIfChanged=ifchanged)

    def _easy_install(self, factory, easy_depends, env):
        for pkg_spec in easy_depends:
            if isinstance(pkg_spec, basestring):
                pkg_spec = [pkg_spec]
            cmd = ['easy_install'] + list(pkg_spec)
            factory.addStep(ShellCommand(command=cmd, env=env))

    def _pip_install(self, factory, pip_depends, env):
        for pkg_spec in pip_depends:
            # We need the 'ignore-installed' flag to force pip to install the
            # programs in the virtualenv.  Otherwise pip finds the programs
            # (like 'nose') already installed; these then call the system
            # python and we don't get the virtualenv python.
            if isinstance(pkg_spec, basestring):
                pkg_spec = [pkg_spec]
            cmd = ['pip', 'install', '--ignore-installed']  # fresh install
            factory.addStep(ShellCommand(command=cmd + list(pkg_spec),
                        env=env))

    def _make_virtualenv(self, factory, python=None, install_pip=True):
        # Obviously requires virtualenv on the slave
        # Because of the bug in elderly easy_install, it would take into
        # account settings present in setup.cfg and might try to install
        # under /usr/lib as happened with fail2ban bot.  So deploy virtualenv
        # while stepping into a new clean directory.
        venv_params = ['--distribute', '--system-site-packages', '../venv']
        if not python is None:
            venv_params = ['--python=' + python] + venv_params
        factory.addStep(ShellCommand(command=['virtualenv'] + venv_params,
                                     workdir='build/mk_venv'))
        # Now we need the venv binary directory
        factory.addStep(FileDownload('slave_scripts/bs_tools.py',
                                     'bs_tools.py'))
        factory.addStep(SetPropertyFromCommand(command=shlex.split(
            'python bs_tools.py path-prepend-str venv'),
            property='venv_script_dir'))
        factory.addStep(SetPropertyFromCommand(command=shlex.split(
            'python bs_tools.py abspath venv'),
            property='venv_dir'))
        # Set env, with virtualenv in front of the path
        env={'PATH': Interpolate("%(prop:venv_script_dir)s${PATH}")}
        workdir = Interpolate("%(prop:venv_dir)s")
        if install_pip:
            # Upgrade setuptools and pip if necessary for wheel installs
            # Can't install pip with pip because it can't delete itself
            factory.addStep(ShellCommand(
                command=['easy_install', '-U', 'pip>=1.4'],
                env=env))
        # Can't install easy_install with easy_install because it can't delete
        # itself.  Use the bootstrap script to avoid version conflict problems
        # from setuptools' nuclear path behavior.
        factory.addStep(ShellCommand(
            command = ['python', 'bs_tools.py', 'get-url', EZ_SETUP_URL,
            'ez_setup.py']))
        if install_pip:
            factory.addStep(ShellCommand(
                command=['python', 'ez_setup.py'],
                env=env))
        return env, workdir

    def _code_build_factory(self,
                            python=None,
                            easy_depends=None,
                            pip_depends=None,
                            pre_build_cmds=(),
                            branch=None,
                            install_pip=None):
        if easy_depends is None:
            easy_depends = self.easy_depends
        if pip_depends is None:
            pip_depends = self.pip_depends
        factory = BuildFactory()
        git_kwargs = {'branch': branch} if branch is not None else {}
        factory.addStep(Git(repourl=self.git_url, mode='full', retry=(15, 5), **git_kwargs))
        # Make virtualenv, return environment, workdir of venv
        my_env, workdir = self._make_virtualenv(
            factory, python,
            install_pip=bool(install_pip or easy_depends or pip_depends))
        # Any pre-building commands
        for cmd in pre_build_cmds:
            factory.addStep(ShellCommand(command=cmd))
        # Add install and runtime dependencies
        self._easy_install(factory, easy_depends, my_env)
        self._pip_install(factory, pip_depends, my_env)
        # Work out working directory for install
        if not self.src_subdir is None:
            factory.addStep(SetPropertyFromCommand(command=[
                'python', 'bs_tools.py', 'abspath', self.src_subdir],
                property='src_path'))
            build_workdir = Interpolate("%(prop:src_path)s")
        else:
            build_workdir = None
        return factory, my_env, workdir, build_workdir

    def factory(self,
                test_cmd=None,
                python=None,
                easy_depends=None,
                pip_depends=None,
                pre_build_cmds=(),
                post_cmds=(),
                test_env=None,
                test_dir=None,
                install_cmd=('python', 'setup.py', 'install'),
                install_wd=None,
                branch=None,
        ):
        if test_cmd is None:
            test_cmd = self.test_cmd
        if test_env is None:
            test_env = self.test_env
        if test_dir is None:
            test_dir = self.test_dir
        factory, env, workdir, build_workdir = self._code_build_factory(
            python, easy_depends, pip_depends, pre_build_cmds, branch=branch)
        # Additional options for ShellCommands, if provided.  To not
        # rely on knowing internal logic (either handles None as the
        # default value), we explicitly construct a dictionary only
        # with the specified options
        kwargs = {}
        if self.build_timeout:
            kwargs['timeout'] = self.build_timeout
        # Install into virtualenv
        if install_wd is None:
            install_wd = build_workdir
        if install_cmd is not None:
            factory.addStep(ShellCommand(
                command=install_cmd,
                env=env,
                workdir=install_wd,
                **kwargs))
        # Test
        if test_env:
            env = dict(env.items() + test_env.items())
        if test_dir:
           # allow for interpolations using known know variables
           test_dir_env = {'workdir': workdir, 'build_workdir': build_workdir}
           test_dir_env.update(env)
           test_dir = test_dir % test_dir_env
        else:
            test_dir = workdir
        if isinstance(test_cmd, dict):
            # must be mapping branches to test_cmd
            test_cmd = test_cmd[branch]
        factory.addStep(ShellCommand(command=test_cmd,
            env=env, workdir=test_dir, **kwargs))
        for cmd in post_cmds:
            factory.addStep(ShellCommand(command=shlex.split(cmd, posix=True),
                                         env=env, workdir=workdir, **kwargs))
        return factory

    def bdist_factory(self,
                      bdist_type,
                      test_cmd=None,
                      python=None,
                      easy_depends=None,
                      pip_depends=None,
                      pre_build_cmds=()):
        if test_cmd is None:
            test_cmd = self.test_cmd
        factory, env, workdir, build_workdir = self._code_build_factory(
            python, easy_depends, pip_depends, pre_build_cmds, install_pip=True)
        # Build binary format(s)
        if python is None: # Use virtualenv python
            my_python = 'python'
            build_env = env
        else: # Use specified python
            my_python = python
            # Insert virtualenv into PYTHONPATH for building using virtualenv
            # dependencies
            factory.addStep(SetPropertyFromCommand(command=shlex.split(
                'python bs_tools.py get-python-lib'),
                property='venv_python_lib', env=env))
            build_env = env.copy()
            build_env['PYTHONPATH'] = Interpolate("%(prop:venv_python_lib)s")
        if bdist_type == 'egg':
            factory.addStep(ShellCommand(
                command=[my_python, 'setup.py', 'bdist_egg'],
                env=build_env,
                workdir=build_workdir))
            # Make a mpkg for good measure
            factory.addStep(ShellCommand(
                command=[my_python, 'setup.py', 'bdist_mpkg'],
                env=build_env,
                workdir=build_workdir))
            installer = ['easy_install']
        elif bdist_type == 'exe':
            factory.addStep(ShellCommand(
                command=[my_python, 'setup.py', 'bdist', '--formats=wininst'],
                env=build_env,
                workdir=build_workdir))
            installer = ['easy_install']
        elif bdist_type == 'whl':
            # Install bdist_wheel command
            self._pip_install(factory,
                    ("wheel>=0.21",),
                    env=build_env)
            # Make wheel - always use virtualenv python
            factory.addStep(ShellCommand(
                command=['python', 'setup.py', 'bdist_wheel'],
                env=build_env,
                workdir=build_workdir))
            installer = ['pip', 'install']
        else:
            raise ValueError('What is this?: ' + bdist_type)
        # Find binary installer file
        factory.addStep(SetPropertyFromCommand(
            command=['python', 'bs_tools.py',
                     'glob', 'dist', '*.' + bdist_type],
            property='bdist_file'))
        # Install into virtualenv
        factory.addStep(ShellCommand(
            command = installer + [Interpolate('%(prop:bdist_file)s')],
            env=env))
        # Test
        factory.addStep(
            ShellCommand(
                command=test_cmd,
                env=env,
                workdir=workdir,
                haltOnFailure=True))
        # Upload
        factory.addStep(DirectoryUpload(slavesrc="dist",
                masterdest="public_html/" + self.download_dir))
        return factory

    def doc_factory(self,
                    doc_build_cmd=None,
                    built_doc_src=None,
                    doc_doctest_cmd=None):
        if doc_build_cmd is None:
            doc_build_cmd = self.doc_build_cmd
        if built_doc_src is None:
            built_doc_src = self.built_doc_src
        if None in (doc_build_cmd, built_doc_src):
            raise ValueError("Need defined build command and doc source")
        factory, my_env, workdir, build_workdir = self._code_build_factory()
        # Install into virtualenv
        kwargs = {}
        if self.build_timeout:
            kwargs['timeout'] = self.build_timeout
        factory.addStep(ShellCommand(
            command=['python', 'setup.py', 'install'],
            env=my_env,
            workdir=build_workdir,
            **kwargs))
        # Add install and runtime dependencies
        self._easy_install(factory, self.doc_easy_depends, my_env)
        self._pip_install(factory, self.doc_pip_depends, my_env)
        if not doc_doctest_cmd is None:
            factory.addStep(ShellCommand(command=doc_doctest_cmd, env=my_env))
        factory.addStep(ShellCommand(command=doc_build_cmd, env=my_env))
        factory.addStep(DirectoryUpload(slavesrc=built_doc_src,
                    masterdest="public_html/nightly/" + self.repo + '/doc'))
        return factory

    def build_builders(self, name_slavenames,
                       test_cmd=None,
                       python=None,
                       easy_depends=None,
                       pip_depends=None,
                       pre_build_cmds=(),
                       post_cmds=(),
                       install_cmd=('python', 'setup.py', 'install'),
                       install_wd=None,
                       branches=None,
                       schedulers=None,   # get a new scheduler assigned per each branch
                       ):
        if branches is None:
            branches = self.branches
        builders = []
        for branch in branches:
            branch_builders = self._factory_builders(
                self.factory(test_cmd, python, easy_depends, pip_depends,
                             pre_build_cmds=pre_build_cmds, post_cmds=post_cmds,
                             install_cmd=install_cmd, install_wd=install_wd, branch=branch),
                name_slavenames,
                None if is_one_default_branch(branches, branch) else branch)

            # assign those to a new unique scheduler if that was requested
            if schedulers is not None:
                schedulers.append(
                    self._get_scheduler([b.name for b in branch_builders],
                                        branches, branch))
            builders += branch_builders
        return builders

    def _factory_builders(self, factory, name_slavenames, branch=None):
        builders = []
        for name, slavelist in name_slavenames:
            if isinstance(slavelist, basestring):
                slavelist = [slavelist]
            if branch is not None:
                name=get_branch_builder_name(name, [None, None], branch)
            builders.append(BuilderConfig(
                name=name,
                slavenames=slavelist,
                factory=factory))
        return builders

    def build_doc_builders(self,
            name_slavenames,
            doc_build_cmd=None,
            built_doc_src=None,
            doc_doctest_cmd=None):
        factory = self.doc_factory(doc_build_cmd, built_doc_src, doc_doctest_cmd)
        return self._factory_builders(factory, name_slavenames)


def nptest_command(pkg_name,
                   verbose=10,
                   doctests=False,
                   python='python',
                   cd=False,
                   stdout=False,
                   exe=False,
                   use_agg=False):
    """ Run tests from new directory """
    pystr = ''
    if cd:
        pystr += "import os; os.chdir('..');"
    if use_agg:
        pystr += 'import os; open("matplotlibrc", "wt").write("backend : agg"); '
    pystr += ("import sys; import %s; sys.exit(not %s.test(doctests=%s"
              % (pkg_name, pkg_name, doctests))
    if verbose != None:
        pystr += ', verbose=%d' % verbose
    if exe:
        pystr += ', extra_argv=["--exe"]'
    pystr += ").wasSuccessful())"
    return [python, '-c', "%s" % pystr]


nibabel_bot = GithubBot('nipy', 'nibabel',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe --with-doctest nibabel nisext'),
    doc_build_cmd = "cd doc && make html",
    built_doc_src = "build/html",
    pip_depends = ('nose',)
)
nitime_bot = GithubBot('nipy', 'nitime',
    test_cmd = nptest_command('nitime', verbose=None),
    pip_depends = ('nose',)
)
pyarbus_bot = GithubBot('ivanov', 'pyarbus',
    test_cmd = nptest_command('pyarbus', verbose=None, use_agg=True),
    pip_depends = ('nose','nitime')
)
nipy_bot = GithubBot('nipy', 'nipy',
    test_cmd = nptest_command('nipy', doctests=True),
    doc_build_cmd = "cd doc && make dist",
    built_doc_src = "doc/dist",
    pip_depends = ('nose', 'sympy', 'nibabel')
)
dipy_bot = GithubBot('nipy', 'dipy',
    test_cmd = ['python', '-c',
    'import nose; '
    'from nose.plugins import doctests ;'
    'open("matplotlibrc", "wt").write("backend : agg"); '
    'argv = ["", "", "--with-doctest", "--verbosity=3", "--exe", "dipy"]; '
    'nose.core.TestProgram(argv=argv, addplugins=[doctests.Doctest()])'],
    pip_depends = ('nose', 'cython>=0.17', 'nibabel')
)
# dipy bot for linux machines with optional easy_depends and pip_depends that
# need an X window for testing
dipy_bot_nox = GithubBot('nipy', 'dipy',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --with-doctest dipy'),
    easy_depends = ('nose', 'nibabel')
)
nipype_bot = GithubBot('nipy', 'nipype',
    test_cmd = nptest_command('nipype', doctests=True),
    easy_depends = ('Traits',),
    pip_depends = ('nose', 'nibabel', 'networkx')
)
regreg_bot = GithubBot('regreg', 'regreg',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe --with-doctest regreg'),
    pip_depends = ('nose',),
)
# pandas bot, primarily for sparc testing
pandas_bot = GithubBot('pydata', 'pandas',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --exe -s pandas'),
    doc_build_cmd = "make doc",
    built_doc_src = "doc/build/html",
    pip_depends = ('nose', 'apiclient',),
    build_timeout = 7200, # allow for its longer builds/testing especially for sparcs
)
# statsmodels bot, primarily for sparc testing
statsmodels_bot = GithubBot('statsmodels', 'statsmodels',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --exe -s statsmodels'),
    doc_build_cmd = "make -C docs html",
    built_doc_src = "docs/build",
    pip_depends = ('nose', 'patsy>=0.1.0',),
)
# seaborn bot
seaborn_bot = GithubBot('mwaskom', 'seaborn',
    test_cmd = shlex.split('xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" nosetests --verbosity=3 --exe -s seaborn'),
    pip_depends = ('nose',),
)
# pymvpa bot, primarily for sparc testing
pymvpa_bot = GithubBot('PyMVPA', 'PyMVPA',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe -s mvpa2'),
    test_env = dict(MVPA_TESTS_LABILE='no', MVPA_MATPLOTLIB_BACKEND='agg', MVPA_TESTS_WTF='yes'),
    doc_build_cmd = "make htmldoc",
    built_doc_src = "build/html",
    pip_depends = ('nose',),
    build_timeout = 3600, # allow for its longer testing especially for sparcs.
)
# sklearn bot, primarily for sparc testing
sklearn_bot = GithubBot('scikit-learn', 'scikit-learn',
    test_cmd = shlex.split('nosetests --verbosity=3 --exe -s sklearn'),
    doc_build_cmd = "make -C doc html",
    built_doc_src = "doc/build",
    easy_depends = ('nose',),
)
# Fail2Ban bots -- need separate ones for different branches because
# tests are invoked differently across them
fail2ban_bot = GithubBot('fail2ban', 'fail2ban',
    test_cmd = {'master': shlex.split('bin/fail2ban-testcases'),
                '0.8': shlex.split('./fail2ban-testcases')},
    branches = ['master', '0.8'],
    test_dir = './build/',
)

# Sympy
sympy_bot = GithubBot('sympy', 'sympy',
    test_cmd = ['python', '-c',
    'import sys; '
    'import sympy; '
    'open("matplotlibrc", "wt").write("backend : agg"); '
    'dt=sympy.doctest(); '
    't=sympy.test(); '
    'st=sympy.test(slow=True, verbose=True, timeout=2300); '
    'sys.exit(not (dt and t and st))'],
    doc_build_cmd = "make html-errors",
    pip_depends = (
        'gmpy==1.16',
        ('--no-deps', 'https://github.com/Theano/Theano/archive/master.zip')),
    doc_pip_depends = ('sphinx==1.1.3',),
    build_timeout = 2400, # allow for very slow sympy tests
)
# Numpy
numpy_bot = GithubBot('numpy', 'numpy',
    test_cmd = nptest_command('numpy', verbose=None),
    pip_depends = ('nose',),
                     )

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

#TODO: We should probably change the GitPoller to a PBChangeSource to react to
# commits http://buildbot.net/buildbot/docs/latest/manual/cfg-changesources.html#chsrc-PBChangeSource
c['change_source'] = [bot.poller() for bot in (nibabel_bot,
                                               nitime_bot,
                                               pyarbus_bot,
                                               nipy_bot,
                                               dipy_bot,
                                               nipype_bot,
                                               regreg_bot,
                                               statsmodels_bot,
                                               seaborn_bot,
                                               pymvpa_bot,
                                               sklearn_bot,
                                               sympy_bot,
                                               numpy_bot,
                                               fail2ban_bot,
                                               )]

# pandas is too expensive to test and overwhelmes the sparc box, so
# let's pull it much less frequently until figuring out how to
# implement **correct** locking
c['change_source'] += [pandas_bot.poller(interval=18000)]


####### SCHEDULERS
# Configure the Schedulers, which decide how to react to incoming changes.

c['schedulers'] = sum([
    nibabel_bot.schedulers(['nibabel-py2.6',
                           'nibabel-py2.6-32',
                           'nibabel-py2.7-win32',
                           'nibabel-py2.7-win7',
                           'nibabel-py2.6-squeeze-sparc',
                           'nibabel-py2.7-wheezy-sparc',
                           'nibabel-py2.x-sid-sparc',
                           'nibabel-py2.7-ppc',
                           'nibabel-py2.6-arm',
                           'nibabel-py2.7-fedora',
                           'nibabel-py2.7-osx-10.6',
                           'nibabel-py2.7-osx-10.7',
                           'nibabel-py2.7-osx-10.8',
                           'nibabel-py2.6-osx-10.5-ppc',
                           'nibabel-py2.6-osx-10.5-intel',
                           'nibabel-py3.4',
                           'nibabel-py3.3',
                           'nibabel-py2.7-pyd0.9.7',
                           'nibabel-py2.7-pyd0.9.8',
                          ]),
    nitime_bot.schedulers(['nitime-py2.6',
                          'nitime-py2.6-32',
                          'nitime-py2.7-win32',
                          'nitime-py2.6-arm',
                          'nitime-py2.7-fedora',
                          'nitime-py2.7-osx-10.6',
                          'nitime-py2.7-osx-10.7',
                          'nitime-py2.7-osx-10.8',
                          'nitime-py3.4',
                          ]),
    pyarbus_bot.schedulers(['pyarbus-py2.6',
                          ]),
    nipy_bot.schedulers(['nipy-py2.6',
                        'nipy-py2.6-32',
                        'nipy-py2.7-win32',
                        'nipy-py2.6-squeeze-sparc',
                        'nipy-py2.7-wheezy-sparc',
                        'nipy-py2.x-sid-sparc',
                        'nipy-py2.7-ppc',
                        'nipy-py2.6-arm',
                        'nipy-py2.7-fedora',
                        'nipy-py2.7-osx-10.6',
                        'nipy-py2.7-osx-10.7',
                        'nipy-py2.7-osx-10.8',
                        'nipy-py2.6-osx-10.5-ppc',
                        'nipy-py2.6-osx-10.5-intel',
                        'nipy-py3.4',
                        'nipy-py3.3',
                        'nipy-py2.7-sym0.7.0-nib1.2.0',
                       ]),
    dipy_bot.schedulers(['dipy-py2.6',
                        'dipy-py2.6-32',
                        'dipy-py2.7-win32',
                        'dipy-py2.6-squeeze-sparc',
                        'dipy-py2.7-wheezy-sparc',
                        'dipy-py2.x-sid-sparc',
                        'dipy-py2.6-arm',
                        'dipy-py2.7-fedora',
                        'dipy-py2.7-osx-10.6',
                        'dipy-py2.7-osx-10.7',
                        'dipy-py2.7-osx-10.8',
                        'dipy-py2.6-osx-10.5-ppc',
                        'dipy-py2.6-osx-10.5-intel',
                        'dipy-py3.4',
                        'dipy-py3.3',
                       ]),
    nipype_bot.schedulers(['nipype-py2.6',
                          'nipype-py2.6-32',
                          'nipype-py2.7-win32',
                          'nipype-py2.7-fedora',
                          'nipype-py2.7-osx-10.6',
                          'nipype-py2.7-osx-10.8',
                          'nipype-py2.6-osx-10.5-ppc',
                          'nipype-py2.6-osx-10.5-intel',
                       ]),
    regreg_bot.schedulers(['regreg-py2.6',
                          'regreg-py2.6-32',
                          'regreg-py2.7-win32',
                          'regreg-py2.7-fedora',
                          'regreg-py2.7-osx-10.6',
                          'regreg-py2.7-osx-10.7',
                          'regreg-py2.7-osx-10.8',
                          'regreg-py2.6-osx-10.5-ppc',
                          'regreg-py2.6-osx-10.5-intel',
                       ]),
    pandas_bot.schedulers([
                        'pandas-py2.x-sid-sparc',
                        'pandas-py3.x-sid-sparc',
                        'pandas-py2.6-wheezy-sparc',
                        'pandas-py2.7-wheezy-sparc',
                        'pandas-py3.x-wheezy-sparc',
                        ]),
    statsmodels_bot.schedulers([
                        'statsmodels-py2.x-sid-sparc',
                        # not yet
                        #'statsmodels-py3.x-sid-sparc',
                        'statsmodels-py2.7-wheezy-sparc',
                        #'statsmodels-py3.x-wheezy-sparc',
                        ]),
    sklearn_bot.schedulers([
                        'sklearn-py2.x-sid-sparc',
                        # not yet
                        #'sklearn-py3.x-sid-sparc',
                        'sklearn-py2.6-wheezy-sparc',
                        #'sklearn-py3.x-wheezy-sparc',
                        ]),
    numpy_bot.schedulers([
                        'numpy-py2.7-osx-10.8',
                        'numpy-py3.3-osx-10.8',
                        'numpy-py3.4-osx-10.8',
                        'numpy-py2.6-osx-10.5-ppc',
                        'numpy-py2.x-sid-sparc',
                        'numpy-py3.x-sid-sparc',
                        ]),], []) + \
    [
    # Doc builds
    nibabel_bot.nightly_scheduler(['nibabel-doc-builder'], 'doc', 2, 20, True),
    nipy_bot.nightly_scheduler(['nipy-doc-builder'], 'doc', 2, 01, True),
    pandas_bot.nightly_scheduler(['pandas-doc-builder'], 'doc', 2, 20, True),
    statsmodels_bot.nightly_scheduler(['statsmodels-doc-builder'], 'doc', 3, 20, True),
    pymvpa_bot.nightly_scheduler(['pymvpa-doc-builder'], 'doc', 4, 20, True),
    # Checks for easy_install and pip install
    # Windows 32 nightly builds
    nipy_bot.nightly_scheduler(['nipy-bdist32-27'], 'exe-27', 2, 10, True),
    nipy_bot.nightly_scheduler(['nipy-bdist32-33'], 'exe-33', 2, 20, True),
    nipy_bot.nightly_scheduler(['nipy-bdist32-34'], 'exe-34', 2, 30, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-27'],
                                  'exe-27', 2, 40, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-27-whl'],
                                  'whl-27', 2, 40, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-33'],
                                  'exe-33', 2, 50, True),
    nibabel_bot.nightly_scheduler(['nibabel-bdist32-34'],
                                  'exe-34', 3, 00, True),
    # Windows 64 nightly builds
    nibabel_bot.nightly_scheduler(['nibabel-bdist64-26'],
                                  'exe64-26', 2, 00, True),
    # OSX nightlies
    nipy_bot.nightly_scheduler(['nipy-bdist-mpkg-2.7'], 'egg-27', 2, 20, True),
    nipy_bot.nightly_scheduler(['nipy-bdist-mpkg-3.3'], 'egg-33', 2, 30, True),
    # Dipy
    # Windows 32 nightly builds
    dipy_bot.nightly_scheduler(['dipy-bdist32-27'], 'dipy-exe-27', 3, 10, True),
    dipy_bot.nightly_scheduler(['dipy-bdist32-33'], 'dipy-exe-33', 3, 20, True),
    dipy_bot.nightly_scheduler(['dipy-bdist32-34'], 'dipy-exe-34', 3, 30, True),
    # OSX nightlies
    dipy_bot.nightly_scheduler(['dipy-bdist-mpkg-2.7'], 'dipy-egg-27', 3, 20, True),
    dipy_bot.nightly_scheduler(['dipy-bdist-mpkg-3.3'], 'dipy-egg-33', 3, 30, True),
    # Sympy slow build at night
    sympy_bot.nightly_scheduler(['sympy-py2.6-32'], 'sympy-slow', 2, 30, True),
    # Sympy binary builders
    sympy_bot.nightly_scheduler(['sympy-bdist32-27'],
                                  'exe-27', 5, 30, True),
    sympy_bot.nightly_scheduler(['sympy-bdist64-27'],
                                  'exe64-27', 5, 30, True),
    # Numpy binary builders
    numpy_bot.nightly_scheduler(['numpy-bdist-whl-osx-2.7'], 'whl-27', 5, 30, True),
    numpy_bot.nightly_scheduler(['numpy-bdist-whl-osx-3.3'], 'whl-33', 5, 30, True),
    numpy_bot.nightly_scheduler(['numpy-bdist-whl-osx-3.4'], 'whl-34', 5, 30, True),
]

# Try scheduler defined after builders

# Some factories

def factory_buildout_nibabel(python='python2.6',numpy='1.6.1'):
    f = BuildFactory()
    # check out the source
    # XXX: the mastersrc should make appropriate changes based on numpy version
    f.addStep(Git(repourl='git://github.com/nipy/nibabel.git', mode='full'))
    f.addStep(FileDownload(mastersrc="bootstrap.py",
                                          slavedest="bootstrap.py"))
    f.addStep(FileDownload(mastersrc="nibabel_buildout.cfg",
                                          slavedest="buildout.cfg"))
    f.addStep(ShellCommand(command=[python, "bootstrap.py"]))
    f.addStep(ShellCommand(command=["bin/buildout"]))
    f.addStep(ShellCommand(nptest_command('nibabel',python='bin/buildoutpython')))
    # run the tests (note that this will require that 'nosetests' is installed)
    #f.addStep(nosetests_command('nibabel', doctests=True))
    return f


def shell_cmd_factory(git_url, cmds, posix=True):
    # Run a series of commands over a git repo
    factory = BuildFactory()
    factory.addStep(Git(
        repourl=git_url,
        mode='full', retry=(15, 5)))
    for cmd in cmds:
        factory.addStep(ShellCommand(command=shlex.split(cmd, posix=posix)))
    return factory


def example_factory(git_url, py_path, out_dir, python_cmd='python'):
    factory = BuildFactory()
    factory.addStep(Git(
        repourl=git_url,
        mode='full', retry=(15, 5)))
    # Touch c files to make sure build doesn't fail because of c file checkout
    # times
    factory.addStep(ShellCommand(command=shlex.split(
        'python tools/touch_cython_cs.py')))
    # Make virtualenv into which to install
    factory.addStep(
        ShellCommand(command=shlex.split(
            py_path + r'/bin/virtualenv --distribute --system-site-packages venv')
            ))
    # Install into virtualenv
    factory.addStep(
        ShellCommand(command=[python_cmd, 'setup.py', 'install'],
                     env={'PATH':
                          Interpolate("%(prop:workdir)s/build/venv/bin:${PATH}")}
            ))
    # Make directory for examples
    factory.addStep(
        ShellCommand(command=['mkdir', 'eg_logs']))
    # Run examples
    factory.addStep(
        ShellCommand(command=[
            python_cmd,
            '../tools/run_log_examples.py',
            '../examples',
            '--log-path=../eg_logs'],
            workdir=r'build/venv',
            env={'PATH': Interpolate("%(prop:workdir)s/build/venv/bin:${PATH}")}
            ))
    # Upload logs
    factory.addStep(DirectoryUpload(slavesrc="eg_logs",
            masterdest="public_html/" + out_dir))
    return factory

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

c['builders'] = []
# nibabel exe builders
nibabel_test_cmd = shlex.split('nosetests --verbosity=3 --with-doctest nibabel')
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-27',
    slavenames=win7_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python27\python.exe')
))
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-27-whl',
    slavenames=win7_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'whl',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python27\python.exe')
))
# The Python32 numpy 1.6.2 installation needs patching according to
# git diff ad9c2f4~1..ad9c2f4
# to remove use of __stdout__ and __stderr__ in numpy distutils
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-33',
    slavenames=win7_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python33\python.exe')
))
c['builders'].append(BuilderConfig(
    name='nibabel-bdist32-34',
    slavenames=win7_32_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python34\python.exe')
))
c['builders'].append(BuilderConfig(
    name='nibabel-bdist64-26',
    slavenames=win7_64_slaves,
    factory=nibabel_bot.bdist_factory(
        'exe',
        test_cmd = nibabel_test_cmd,
        python = r'c:\Python26\python.exe')
))
# nipy exe builders
nipy_test_cmd = nptest_command('nipy', doctests=True)
c['builders'].append(BuilderConfig(
    name='nipy-bdist32-27',
    slavenames=win7_32_slaves,
    factory=nipy_bot.bdist_factory(
        'exe',
        test_cmd = nipy_test_cmd,
        python = r'c:\Python27\python.exe',
        pre_build_cmds = [['python', r'tools\touch_cython_cs.py']])
))
c['builders'].append(BuilderConfig(
    name='nipy-bdist32-33',
    slavenames=win7_32_slaves,
    factory=nipy_bot.bdist_factory(
        'exe',
        test_cmd = nipy_test_cmd,
        python = r'c:\Python33\python.exe',
        pre_build_cmds = [['python', r'tools\touch_cython_cs.py']])
))
c['builders'].append(BuilderConfig(
    name='nipy-bdist32-34',
    slavenames=win7_32_slaves,
    factory=nipy_bot.bdist_factory(
        'exe',
        test_cmd = nipy_test_cmd,
        python = r'c:\Python34\python.exe',
        pre_build_cmds = [['python', r'tools\touch_cython_cs.py']])
))
# Add bdist builders for OSX
# Need exe because easy_install makes tests executable on 3.3
nipy_test_cmd = nptest_command('nipy', doctests=True, exe=True)
c['builders'].append(BuilderConfig(
    name='nipy-bdist-mpkg-2.7',
    slavenames=['osx-10.6'],
    factory=nipy_bot.bdist_factory(
        'egg',
        test_cmd=nipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/2.7/bin/python')
))
c['builders'].append(BuilderConfig(
    name='nipy-bdist-mpkg-3.3',
    slavenames=['osx-10.6'],
    factory=nipy_bot.bdist_factory(
        'egg',
        test_cmd=nipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/3.3/bin/python3')
))
##############################
# Dipy builders
##############################
# We have to jump through some difficult hoops to put the `dipnost` command on
# the path, because multiprocessing gets very unhappy if you try and run stuff
# from a command in a file that is not importable on the Python path, at least
# on Windows 32 bit
win32_dipy_test_cmd = ['python',  r'dipnost.py', 'dipy']
c['builders'].append(BuilderConfig(
    name='dipy-bdist32-27',
    slavenames=win7_32_slaves,
    factory=dipy_bot.bdist_factory(
        'exe',
        # Copy dipnost as py file into (later) working directory
        pre_build_cmds = [['copy', r'tools\dipnost', r'venv\dipnost.py']],
        test_cmd=win32_dipy_test_cmd,
        python=r'c:\Python27\python.exe')
))
c['builders'].append(BuilderConfig(
    name='dipy-bdist32-33',
    slavenames=win7_32_slaves,
    factory=dipy_bot.bdist_factory(
        'exe',
        # Copy dipnost as py file into (later) working directory
        pre_build_cmds = [['copy', r'tools\dipnost', r'venv\dipnost.py']],
        test_cmd=win32_dipy_test_cmd,
        python=r'c:\Python33\python.exe')
))
c['builders'].append(BuilderConfig(
    name='dipy-bdist32-34',
    slavenames=win7_32_slaves,
    factory=dipy_bot.bdist_factory(
        'exe',
        # Copy dipnost as py file into (later) working directory
        pre_build_cmds = [['copy', r'tools\dipnost', r'venv\dipnost.py']],
        test_cmd=win32_dipy_test_cmd,
        python=r'c:\Python34\python.exe')
))
# Add bdist builders for OSX
# Each of the tested _system_ pythons will need:
# * numpy, scipy, virtualenv, bdist_mpkg
osx_dipy_test_cmd = ['python',  '../tools/dipnost', '--exe', '--verbosity=3', 'dipy']
c['builders'].append(BuilderConfig(
    name='dipy-bdist-mpkg-2.7',
    slavenames=['osx-10.6'],
    factory=dipy_bot.bdist_factory(
        'egg',
        test_cmd=osx_dipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/2.7/bin/python')
))
c['builders'].append(BuilderConfig(
    name='dipy-bdist-mpkg-3.3',
    slavenames=['osx-10.6'],
    factory=dipy_bot.bdist_factory(
        'egg',
        test_cmd=osx_dipy_test_cmd,
        python='/Library/Frameworks/Python.framework/Versions/3.3/bin/python3')
))
# sympy binary builders
sympy_test_cmd = ['python', '-c',
                  'import sys; '
                  'import sympy; '
                  'open("matplotlibrc", "wt").write("backend : agg"); '
                  'dt=sympy.doctest(); '
                  't=sympy.test(); '
                  'sys.exit(not (dt and t))']
pip_deps = ('nose',)
for slavenames, bdist_suffix in (
    (win7_32_slaves, '32'),
    (win7_64_slaves, '64')):
    py2_name = 'sympy-bdist{0}-27'.format(bdist_suffix)
    py3_sched_name = 'sympy-bdist{0}-33-scheduler'.format(bdist_suffix)
    py3_build_name = 'sympy-bdist{0}-33-builder'.format(bdist_suffix)
    factory = sympy_bot.bdist_factory(
        'exe',
        test_cmd = sympy_test_cmd,
        pip_depends = pip_deps,
        python = r'c:\Python27\python.exe')
    factory.addStep(
            SetPropertyFromCommand(
                command=['python', 'bs_tools.py', 'get-tail', Property('bdist_file')],
                property='bdist_fname'))
    factory.addStep(
        Trigger(schedulerNames=[py3_sched_name],
                updateSourceStamp=True,
                set_properties={'bdist_fname' : Property('bdist_fname')}
            ))
    c['builders'].append(BuilderConfig(
        name=py2_name,
        slavenames=slavenames,
        factory=factory))
    # Make triggerable scheduler
    c['schedulers'].append(
            Triggerable(name=py3_sched_name, builderNames=[py3_build_name]))
    # Make builder for Python 3 bdist test
    factory = BuildFactory()
    env, workdir = sympy_bot._make_virtualenv(factory,
                                              'c:\Python33\python.exe')
    # Download bdist file
    factory.addStep(
        FileDownload(Interpolate(
            "public_html/" +
            sympy_bot.download_dir +
            "/%(prop:bdist_fname)s"),
            Property('bdist_fname'))
            )
    # easy_install bdist file into virtualenv
    factory.addStep(ShellCommand(
        command=['easy_install', Property('bdist_fname')],
        env=env))
    # pip install nose
    factory.addStep(ShellCommand(
        command=['pip', 'install', '--ignore-installed', 'nose'],
        env=env))
    # run tests
    factory.addStep(ShellCommand(
        command=sympy_test_cmd,
        env=env,
        workdir=workdir))
    c['builders'].append(BuilderConfig(
        name=py3_build_name,
        slavenames=slavenames,
        factory=factory))
# Make numpy wheels on 10.9, test on 10.6
building_slaves = osx_mountainlion_slaves
testing_slaves = osx_snowleopard_slaves
for python_bin, py_ver in (
        ('python', '2.7'),
        ('python3', '3.3'),
        ('python3', '3.4')):
    python_exe = '/Library/Frameworks/Python.framework/Versions/{0}/bin/{1}'.format(py_ver, python_bin)
    builder_name = 'numpy-bdist-whl-osx-' + py_ver
    tester_name = builder_name + '-downloaded'
    test_scheduler_name = tester_name + '-scheduler'
    factory = numpy_bot.bdist_factory('whl', python = python_exe)
    factory.addStep(
            SetPropertyFromCommand(
                command=['python', 'bs_tools.py', 'get-tail', Property('bdist_file')],
                property='bdist_fname'))
    factory.addStep(
        Trigger(schedulerNames=[test_scheduler_name],
                updateSourceStamp=True,
                set_properties={'bdist_fname' : Property('bdist_fname')}
            ))
    c['builders'].append(BuilderConfig(
        name=builder_name,
        slavenames=building_slaves,
        factory=factory))
    # Make triggerable scheduler
    c['schedulers'].append(
            Triggerable(name=test_scheduler_name, builderNames=[tester_name]))
    # Make downloading builder for other osx version
    factory = BuildFactory()
    env, workdir = numpy_bot._make_virtualenv(factory, python_exe)
    # Download bdist file
    factory.addStep(
        FileDownload(Interpolate(
            "public_html/" +
            numpy_bot.download_dir +
            "/%(prop:bdist_fname)s"),
            Property('bdist_fname'))
            )
    # Upgrade pip so it can use wheels
    factory.addStep(ShellCommand(
        command=['easy_install', '-U', 'pip'],
        env=env))
    # pip install bdist file into virtualenv
    factory.addStep(ShellCommand(
        command=['pip', 'install', Property('bdist_fname')],
        env=env))
    # pip install nose
    factory.addStep(ShellCommand(
        command=['pip', 'install', '--ignore-installed', 'nose'],
        env=env))
    # run tests
    factory.addStep(ShellCommand(
        command=numpy_bot.test_cmd,
        env=env,
        workdir=workdir))
    c['builders'].append(BuilderConfig(
        name=tester_name,
        slavenames=testing_slaves,
        factory=factory))

# Add nightly docs builders
c['builders'] += nipy_bot.build_doc_builders(
    (('nipy-doc-builder', linux_64_slaves),),
    doc_doctest_cmd = "cd doc && make doctest"
)
c['builders'] += nibabel_bot.build_doc_builders(
    (('nibabel-doc-builder', linux_64_slaves),))
c['builders'] += pandas_bot.build_doc_builders(
    (('pandas-doc-builder', sparc_slaves_sid),))
c['builders'] += statsmodels_bot.build_doc_builders(
    (('statsmodels-doc-builder', sparc_slaves_sid),))
c['builders'] += pymvpa_bot.build_doc_builders(
    (('pymvpa-doc-builder', sparc_slaves_sid),))

# pre-release builders
def inplace_cmd_factory(bot, commands, **kwargs):
    factory, env, workdir, buildir = bot._code_build_factory(**kwargs)
    factory.addStep(ShellCommand(
        command=('python', 'setup.py', 'build_ext', '-i'),
        env=env))
    for cmd in commands:
        factory.addStep(ShellCommand(command=cmd, env=env))
    return factory

c['builders'].append(BuilderConfig(
    name='nipy-release-checks',
    slavenames=['osx-10.6'],
    factory=inplace_cmd_factory(nipy_bot,
        (('make', 'distclean'),
         ('python', '-m', 'compileall', '.'),
         ('make', 'sdist-tests'),
         ('make', 'bdist-egg-tests'),
         ('make', 'check-version-info'),
         ('make', 'check-files')),
                               )))
c['builders'].append(BuilderConfig(
    name='dipy-release-checks',
    slavenames=['osx-10.6'],
    factory=inplace_cmd_factory(dipy_bot,
        (('make', 'distclean'),
         ('python', '-m', 'compileall', '.'),
         ('make', 'sdist-tests'),
         ('make', 'bdist-egg-tests'),
         ('make', 'check-version-info'),
         ('make', 'check-files')),
        )))

# Example builders
c['builders'].append(BuilderConfig(
    name='nipy-examples-2.6',
    slavenames=['osx-10.6'],
    factory=example_factory(
        'git://github.com/nipy/nipy.git',
        '/Library/Frameworks/Python.framework/Versions/2.6',
        "nipy-examples-2.6")
))
c['builders'].append(BuilderConfig(
    name='nipy-examples-3.3',
    slavenames=['osx-10.6'],
    factory=example_factory(
        'git://github.com/nipy/nipy.git',
        '/Library/Frameworks/Python.framework/Versions/3.3',
        "nipy-examples-3.3",
        "python3")
))
# pip and easy_install builders
hours = 5
minutes = 0
for bot in (nibabel_bot, nipy_bot, dipy_bot):
    for pyver in ('2.7', '3.3'):
        project = bot.repo
        for install_cmd in (
                ('pip', 'install', '--ignore-installed', project),
                ('easy_install', '-U', project)):
            name_suff =  'py%s-%s' % (pyver, install_cmd[0])
            builder_name = '%s-%s' % (project, name_suff)
            # need nose dev version for fix to easy_install installations here:
            # https://github.com/nose-devs/nose/pull/661
            # When nose releases next version (after 1.3.0) can drop this
            if install_cmd[0] == 'easy_install':
                nose_target = 'git+git://github.com/nose-devs/nose.git'
            else:
                nose_target = 'nose'
            c['builders'] += bot.build_builders(
                ((builder_name, osx_mountainlion_slaves),),
                python='python' + pyver,
                easy_depends = (), # Turn off dependency install
                pip_depends = (nose_target,), # ditto
                install_cmd = install_cmd,
                install_wd = 'build/venv')
            c['schedulers'] += bot.nightly_scheduler(
                    [builder_name],
                    name_suff,
                    hours,
                    minutes,
                    True),
            minutes += 10
            if minutes == 60:
                hours += 1
                minutes = 0

# Code builders
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py2.6', linux_64_slaves),
     ('nibabel-py2.6-32', linux_32_slaves),
     ('nibabel-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nibabel-py2.7-osx-10.7', osx_lion_slaves),
     ('nibabel-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nibabel-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nibabel-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nibabel-py2.7-ppc', debian_ppc_slaves),
     ('nibabel-py2.6-arm', arm_slaves),
     ('nibabel-py2.7-fedora', fedora_slaves),
     ('nibabel-py2.7-win32', win7_32_slaves),
     ('nibabel-py2.7-win7', win7_64_slaves),
     ('nibabel-py2.6-squeeze-sparc', sparc_slaves),
     ('nibabel-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('nibabel-py2.x-sid-sparc', sparc_slaves_sid)))
# Python 3s into virtualenv
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py3.4', linux_64_slaves),),
    python='python3.4')
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py3.3', osx_snowleopard_slaves),),
    python='python3.3')
# Different versions of Pydicom
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py2.7-pyd0.9.7', osx_mountainlion_slaves),),
    python='python2.7',
    pip_depends = ('nose', 'pydicom==0.9.7'))
c['builders'] += nibabel_bot.build_builders(
    (('nibabel-py2.7-pyd0.9.8', osx_mountainlion_slaves),),
    python='python2.7',
    pip_depends = ('nose', 'pydicom==0.9.8'))
# Nitime
c['builders'] += nitime_bot.build_builders(
    (('nitime-py2.6', linux_64_slaves),
     ('nitime-py2.6-32', linux_32_slaves),
     ('nitime-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nitime-py2.7-osx-10.7', osx_lion_slaves),
     ('nitime-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nitime-py2.6-arm', arm_slaves),
     ('nitime-py2.7-fedora', fedora_slaves),
     ('nitime-py2.7-win32', win7_32_slaves))
    )
c['builders'] += nitime_bot.build_builders(
    (('nitime-py3.4', linux_64_slaves),),
    python='python3.4')

# pyarbus
c['builders'] += pyarbus_bot.build_builders(
    (('pyarbus-py2.6', linux_64_slaves),))
c['builders'] += nipy_bot.build_builders(
    (('nipy-py2.6', linux_64_slaves),
     ('nipy-py2.6-32', linux_32_slaves),
     ('nipy-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nipy-py2.7-osx-10.7', osx_lion_slaves),
     ('nipy-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nipy-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nipy-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nipy-py2.7-ppc', debian_ppc_slaves),
     ('nipy-py2.6-arm', arm_slaves),
     ('nipy-py2.7-fedora', fedora_slaves),
     ('nipy-py2.7-win32', win7_32_slaves),
     ('nipy-py2.6-squeeze-sparc', sparc_slaves),
     ('nipy-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('nipy-py2.x-sid-sparc', sparc_slaves_sid)))
# Python 3s into virtualenv
c['builders'] += nipy_bot.build_builders(
    (('nipy-py3.4', linux_64_slaves),),
    python='python3.4')
c['builders'] += nipy_bot.build_builders(
    (('nipy-py3.3', osx_snowleopard_slaves),),
    python='python3.3')
# Different versions of Sympy, nibabel
c['builders'] += nipy_bot.build_builders(
    (('nipy-py2.7-sym0.7.0-nib1.2.0', osx_mountainlion_slaves),),
    pip_depends = ('nose', 'sympy==0.7.0', 'nibabel==1.2.0'))
# The dipy builder seems to fail early sometimes, on OSX, maybe due to:
# http://bugs.python.org/issue8458
c['builders'] += dipy_bot_nox.build_builders(
    (('dipy-py2.6', linux_64_slaves),
     ('dipy-py2.6-32', linux_32_slaves),
))
c['builders'] += dipy_bot.build_builders((
     ('dipy-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('dipy-py2.7-osx-10.7', osx_lion_slaves),
     ('dipy-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('dipy-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('dipy-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('dipy-py2.6-arm', arm_slaves),
     ('dipy-py2.7-fedora', fedora_slaves),
     ('dipy-py2.7-win32', win7_32_slaves),
     ('dipy-py2.6-squeeze-sparc', sparc_slaves),
     ('dipy-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('dipy-py2.x-sid-sparc', sparc_slaves_sid)))
# Python 3.2 into virtualenv
c['builders'] += dipy_bot.build_builders(
    (('dipy-py3.4', linux_64_slaves),),
    python='python3.4')
c['builders'] += dipy_bot.build_builders(
    (('dipy-py3.3', osx_snowleopard_slaves),),
    python='python3.3')
# Nipype
c['builders'] += nipype_bot.build_builders(
    (('nipype-py2.6', linux_64_slaves),
     ('nipype-py2.6-32', linux_32_slaves),
     ('nipype-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('nipype-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('nipype-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('nipype-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('nipype-py2.7-fedora', fedora_slaves),
     ('nipype-py2.7-win32', win7_32_slaves)))
c['builders'] += regreg_bot.build_builders(
    (('regreg-py2.6', linux_64_slaves),
     ('regreg-py2.6-32', linux_32_slaves),
     ('regreg-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('regreg-py2.7-osx-10.7', osx_lion_slaves),
     ('regreg-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('regreg-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('regreg-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('regreg-py2.7-fedora', fedora_slaves),
     ('regreg-py2.7-win32', win7_32_slaves)))
# Pandas - can be tested only on recent debian releases
c['builders'] += pandas_bot.build_builders(
    (('pandas-py2.x-sid-sparc', sparc_slaves_sid),
     ('pandas-py2.7-wheezy-sparc', sparc_slaves_wheezy)),
    post_cmds=("python -c 'from pandas.util.print_versions import show_versions; show_versions()'",))
# test on wheezy for python2.6
c['builders'] += pandas_bot.build_builders(
    (('pandas-py2.6-wheezy-sparc', sparc_slaves_wheezy),),
    python='python2.6')
# and python3 builders
c['builders'] += pandas_bot.build_builders(
    (('pandas-py3.x-sid-sparc', sparc_slaves_sid),
     ('pandas-py3.x-wheezy-sparc', sparc_slaves_wheezy)),
    post_cmds=("python3 -c 'from pandas.util.print_versions import show_versions; show_versions()'",),
    python='python3')
# Statsmodels - can be tested only on recent debian releases
c['builders'] += statsmodels_bot.build_builders(
    (('statsmodels-py2.x-sid-sparc', sparc_slaves_sid),
     ('statsmodels-py2.7-wheezy-sparc', sparc_slaves_wheezy)),
    post_cmds=("python -c 'from statsmodels.tools.print_version import show_versions; show_versions()'",))
# Seaborn
c['builders'] += seaborn_bot.build_builders(
    (('seaborn-py2.x-sid-sparc', sparc_slaves_sid),
     ('seaborn-py2.7-wheezy-sparc', sparc_slaves_wheezy)),
    schedulers=c['schedulers']
    )
## and python3 builders
#c['builders'] += statsmodels_bot.build_builders(
#    (('statsmodels-py3.x-sid-sparc', sparc_slaves_sid),
#     ('statsmodels-py3.x-wheezy-sparc', sparc_slaves_wheezy)),
#    python='python3')
# PyMVPA
c['builders'] += pymvpa_bot.build_builders(
    (('pymvpa-py2.x-sid-sparc', sparc_slaves_sid),
     ('pymvpa-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('pymvpa-py2.7-osx-10.6', osx_snowleopard_slaves),
     ('pymvpa-py2.7-osx-10.7', osx_lion_slaves),
     ('pymvpa-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('pymvpa-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('pymvpa-py2.6-osx-10.5-intel', osx_leopard_intel_slaves),
     ('pymvpa-py2.7-win32', win7_32_slaves),
    ), schedulers=c['schedulers'])
# Sklearn
c['builders'] += sklearn_bot.build_builders((
    ('sklearn-py2.x-sid-sparc', sparc_slaves_sid),))
c['builders'] += sklearn_bot.build_builders((
    ('sklearn-py2.6-wheezy-sparc', sparc_slaves_wheezy),),
    python='python2.6')
""" Disabling these guys; they haven't worked for a while
c['builders'].append(
    BuilderConfig(name="buildout-test2.6",
      slavenames=experimental,
      factory=factory_buildout_nibabel()))
c['builders'].append(
    BuilderConfig(name="buildout-test2.5",
      slavenames=experimental,
      factory=factory_buildout_nibabel('python2.5')))
c['builders'].append(
    BuilderConfig(name="buildout-test2.4",
      slavenames=experimental,
      factory=factory_buildout_nibabel('python2.4')))
"""
# Fail2ban
c['builders'] += fail2ban_bot.build_builders(
    (('fail2ban-py2.x-sid-sparc', sparc_slaves_sid),
     ('fail2ban-py2.7-wheezy-sparc', sparc_slaves_wheezy),
     ('fail2ban-py2.6-osx-10.6', osx_snowleopard_slaves),
     ('fail2ban-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('fail2ban-py2.7-ppc', debian_ppc_slaves),
     ('fail2ban-py2.6-arm', arm_slaves),
     # ('fail2ban-py2.7-win7', win7_64_slaves),
    ),
    schedulers=c['schedulers'],           # in-place modify
    install_cmd=None)
# master does not support 2.5
c['builders'] += fail2ban_bot.build_builders(
    (
        ('fail2ban-py2.5-osx-10.5-intel', osx_leopard_intel_slaves),
        ('fail2ban-py2.5-osx-10.5-ppc', osx_leopard_ppc_slaves),),
    branches=['0.8'],
    install_cmd=None)
# Sympy
c['builders'] += sympy_bot.build_builders(
    (('sympy-py2.6-32', linux_32_slaves),
    ))
c['builders'] += numpy_bot.build_builders(
    (('numpy-py2.7-osx-10.8', osx_mountainlion_slaves),
     ('numpy-py3.3-osx-10.8', osx_mountainlion_slaves),
     ('numpy-py3.4-osx-10.8', osx_mountainlion_slaves),
     ('numpy-py2.6-osx-10.5-ppc', osx_leopard_ppc_slaves),
     ('numpy-py2.x-sid-sparc', sparc_slaves_sid),
    ))
c['builders'] += numpy_bot.build_builders(
    (('numpy-py3.x-sid-sparc', sparc_slaves_sid),
     ), python='python3')

def wheel_factory(python_version, pip_installs,
                  test_commands=(),
                  find_links=()):
    """ Make a factory for the wheel build slave """
    # OSX wheel builders
    whl_fac = BuildFactory()
    # Delete previous build products
    whl_fac.addStep(ShellCommand(command=
        ['rm', '-rf', 'venv', 'bs_tools.py']))
    # Install fresh Python and pip
    whl_fac.addStep(ShellCommand(command=
        ['sudo', '/usr/local/bin/install_python.py', python_version]))
    pip_cmd = ['pip', 'install'] + ['--find-links=' + s for s in find_links]
    # Install into virtualenv
    whl_fac.addStep(ShellCommand(command=['virtualenv', 'venv']))
    # Now we need the venv binary directory
    whl_fac.addStep(FileDownload('slave_scripts/bs_tools.py',
                                 'bs_tools.py'))
    whl_fac.addStep(SetPropertyFromCommand(
        command = ['python', 'bs_tools.py', 'path-prepend-str', 'venv'],
        property = 'venv_script_dir'))
    whl_fac.addStep(SetPropertyFromCommand(
        command = ['python', 'bs_tools.py', 'abspath', 'venv'],
        property = 'venv_dir'))
    whl_fac.addStep(SetPropertyFromCommand(
        command = ['python', 'bs_tools.py', 'abspath', 'bs_tools.py'],
        property = 'bs_tools'))
    # Set env, with virtualenv in front of the path
    env = {'PATH': Interpolate("%(prop:venv_script_dir)s${PATH}")}
    workdir = Interpolate("%(prop:venv_dir)s")
    for name, version, pre_tf in pip_installs:
        if version:
            if version == '-r':
                names = ['-r', name]
            elif pre_tf:
                raise ValueError("cannot use --pre flag with version")
            else:
                names = ['{0}=={1}'.format(name, version)]
        else:
            names = [name]
        if pre_tf:
            names = ['--pre'] + names
        whl_fac.addStep(ShellCommand(command=pip_cmd + names,
                                     env=env,
                                     workdir=workdir))
    for test_command in test_commands:
        whl_fac.addStep(ShellCommand(command=test_command,
                                     env=env,
                                     workdir=workdir))
    return whl_fac


WHEEL_SERVER = HTTP_SERVER_URL
# Cached copy of
# https://raw.githubusercontent.com/matplotlib/matplotlib/master/tests.py
MPL_TESTS_FNAME = 'mpl_tests.py'
MPL_TESTS_URL = HTTP_CACHE_URL + MPL_TESTS_FNAME
SCIPY_EXCLUDE_TESTS = [
    # https://github.com/scipy/scipy/issues/3853
    'test_no_64',
    'test_resiliency_all_32',
    'test_resiliency_all_64',
    'test_resiliency_limit_10',
    'test_resiliency_random',
    'test_ufunc_object_array',
    'test_unary_ufunc_overrides',
    'test_binary_ufunc_overrides',
]
scipy_extra_argv = ['--exclude=' + regex for regex in SCIPY_EXCLUDE_TESTS]

scipy_test_args = 'extra_argv=[{0}]'.format(
    ', '.join(['"{0}"'.format(p) for p in scipy_extra_argv]))

scipy_test_cmd = ['python', '-c',
                  'import sys; '
                  'import scipy; '
                  'sys.exit(not scipy.test({0}))'.format(scipy_test_args)]
mpl_test_setup1 = ['python', Property('bs_tools'), 'get-url', MPL_TESTS_URL, MPL_TESTS_FNAME]
mpl_test_setup2 = ['python', '-c',
                   'import os, shutil; '
                   'shutil.rmtree(os.path.expanduser("~/.matplotlib"))']
# Known mpl test failure for Python 3.4
# https://github.com/matplotlib/matplotlib/pull/2981
mpl_test_cmd = ['python', MPL_TESTS_FNAME]
numexpr_test_cmd = ['python', '-c',
                    'import sys; '
                    'import numexpr; '
                    'sys.exit(not numexpr.test())']
h5_test_cmd = ['python', '-c',
               'import sys; '
               'import unittest; '
               'suite = unittest.TestLoader().discover("h5py"); '
               'res = unittest.TextTestRunner(verbosity=3).run(suite); '
               'sys.exit(not res.wasSuccessful)']
sympy_whl_test_cmd = ['python', '-c',
                      'import sys; '
                      'import sympy; '
                      # too slow for full tests
                      'sys.exit(not sympy.test("/basic", "/util"))']
test_commands = [['nosetests', 'markupsafe'],
                 # Tornado tests failing on this system
                 # See: https://github.com/tornadoweb/tornado/issues/1228
                 # ['python', '-m', 'tornado.test.runtests'],
                 nptest_command('numpy', verbose=None),
                 scipy_test_cmd,
                 mpl_test_setup1,
                 mpl_test_setup2,
                 mpl_test_cmd,
                 ['iptest'],
                 # Some known fails for pandas tests version 0.15
                 ['nosetests', 'pandas',
                 # https://groups.google.com/d/msg/pydata/AzMPFAE9bhw/hs4H516gS4YJ
                 '-e', 'test_clipboard'],
                 h5_test_cmd,
                 numexpr_test_cmd,
                 sympy_whl_test_cmd]

default_requires = WHEEL_SERVER + 'scipy-stats-data-1.0.txt'
wheel_requires = Property('wheel_requires', default_requires)
build_hour = 11
for py_version in '2.7.6', '3.3.5', '3.4.1':
    for find_links, pre, suffix in (((), False, 'pypi'),
                                    ((WHEEL_SERVER,), False, 'staging'),
                                    ((WHEEL_SERVER,), True, 'pre')):
        c['builders'].append(BuilderConfig(
            name='scipy-stack-{0}-wheel-{1}'.format(py_version, suffix),
            slavenames=osx_wheel_slaves,
            factory = wheel_factory(py_version,
                                    (('nose', '', pre),
                                     ('numpy', '', pre),
                                     ('scipy', '', pre),
                                     ('matplotlib', '', pre),
                                     ('numexpr', '', pre),
                                     ('pandas', '', pre),
                                     ('sympy', '', pre),
                                     ('ipython[notebook,test]', '', pre),
                                     ('h5py', '', pre)),
                                    test_commands = test_commands,
                                    build_timeout=2400,
                                    find_links = find_links)))
    requires_builder_name = 'scipy-stack-{0}-wheel-requires'.format(py_version)
    c['builders'].append(BuilderConfig(
        name=requires_builder_name,
        slavenames=osx_wheel_slaves,
        factory = wheel_factory(py_version,
                                ((wheel_requires, '-r', False),),
                                test_commands = test_commands,
                                find_links = ())))
    requires_scheduler_name = requires_builder_name + "-scheduler"
    build_hour += 1
    c['schedulers'].append(timed.Nightly(
                    name=requires_scheduler_name,
                    branch=None,
                    builderNames=[requires_builder_name],
                    change_filter=None,
                    hour=build_hour,
                    minute=0,
                    onlyIfChanged=False))
    c['schedulers'].append(ForceScheduler(
        name=requires_builder_name,
        builderNames=[requires_builder_name],
        properties= [StringParameter(name="wheel_requires",
                    label="set pip requires file for installation",
                    default=default_requires, size=200)]))


# Assign all builders categories -- project names, to improve status visualizations
for b in c['builders']:
    b.category = b.name.split('-')[0]

# Add force scheduler to all builders that don't have one
scheduler_names = [s.name for s in c['schedulers']
                   if isinstance(s, ForceScheduler)]
for b in c['builders']:
    if not b.name in scheduler_names:
        c['schedulers'].append(
            ForceScheduler(name=b.name, builderNames=[b.name]))


####### Try scheduler for any build
c['schedulers'].append(
    Try_Jobdir(name="try1",
               builderNames=[builder.name for builder in c['builders']],
               jobdir="jobdir"))

# A build seemed to work with this command from a dipy repo directory
# $ buildbot try -c ssh -u buildbot --vc=git -b dipy-py2.7-osx-10.8 --host=nipy.bic.berkeley.edu --jobdir=~buildbot/nibotmi/jobdir --branch=master

####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html, mail
from buildbot.status.web import auth, authz

c['status'].append(mail.MailNotifier(fromaddr="buildbot@nipy.bic.berkeley.edu",
                      mode='failing',
                      categories=('sympy',),
                      sendToInterestedUsers=False,
                      extraRecipients=['asmeurer@gmail.com']))

c['status'].append(mail.MailNotifier(fromaddr="buildbot@nipy.bic.berkeley.edu",
                      mode='failing',
                      categories=('seaborn',),
                      sendToInterestedUsers=False,
                      extraRecipients=['site-buildbot-nipy@onerussian.com', 'mwaskom@stanford.edu']))

c['status'].append(mail.MailNotifier(fromaddr="buildbot@nipy.bic.berkeley.edu",
                      mode='failing',
                      categories=('pymvpa',),
                      sendToInterestedUsers=True,
                      extraRecipients=['site-buildbot-nipy@onerussian.com']))

c['status'].append(mail.MailNotifier(fromaddr="buildbot@nipy.bic.berkeley.edu",
                      mode='failing',
                      categories=('fail2ban',),
                      sendToInterestedUsers=False,
                      extraRecipients=['fail2ban-buildbots@lists.sourceforge.net']))

# Allow builds to be triggered via the web forms
sympy_release_filter = ChangeFilter(category="release", repository="sympy")
rel_sched = SingleBranchScheduler(name="sympy-release",
                                  change_filter=sympy_release_filter,
                                  builderNames=['sympy-bdist32-27',
                                                'sympy-bdist64-27']
                                 )
c['schedulers'].append(rel_sched)

http_auth = auth.HTPasswdAuth('bot_htpasswd')

authz_cfg=authz.Authz(
    auth = http_auth,
    # change any of these to True to enable; 'auth' to require authorization'
    # see the manual for more options
    gracefulShutdown = False,
    forceBuild = 'auth',
    forceAllBuilds = 'auth',
    pingBuilder = False,
    stopBuild = 'auth',
    stopAllBuilds = False,
    cancelPendingBuild = 'auth',
)
c['status'].append(html.WebStatus(
    http_port=8010,
    authz=authz_cfg,
    change_hook_dialects={'base': True}
))

####### PROJECT IDENTITY
# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "NiPy"
c['titleURL'] = "http://nipy.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = local_setup.master_url

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

# Set mime types for server serving non buildbot files
from twisted.web.static import File
webdir = File("public_html")
webdir.contentTypes['.egg'] = 'application/octet-stream'
webdir.contentTypes['.whl'] = 'application/octet-stream'

# Allow patches of up to 1M in size
from twisted.protocols.basic import NetstringReceiver
NetstringReceiver.MAX_LENGTH = 1000000

import re
def _select_builders(builders, regex):
    r = re.compile(regex)
    return [b for b in builders
            if r.match(b.name)]


def _test_easy_and_no_easy(c, regex, command, expect=True):
    for builder in _select_builders(c['builders'], regex):
        # 2nd one is virtualenv always
        assert(builder.factory.steps[1].kwargs['command'][0] == 'virtualenv')
        for step in builder.factory.steps:
            if command in step.kwargs.get('command', []):
                if expect:
                    return
                else:
                    raise AssertionError(
                        "%s builders should not invoke %s."
                        " Got builder %s running command %s"
                        % (prefix, command, builder.name,
                            ' '.join(step.kwargs.get('command'))))
    if expect:
        raise AssertionError(
            "None of the %s builders invoked expected %s" % (prefix, command))


def test_easy_and_no_easy(c):
    _test_easy_and_no_easy(c, '^fail2ban-.*', expect=False, command='easy_install')
    _test_easy_and_no_easy(c, '^nipy-.*', expect=True, command='easy_install')


def test_fail2ban_08_state(c):
    builders = _select_builders(c['builders'], 'fail2ban-py2\.5-osx-10\.5-ppc.*')
    # we should still have branch suffix since it is not master
    assert(builders[0].name == 'fail2ban-py2.5-osx-10.5-ppc_0.8')


def test_regression(c):
    print "# builders:   ", len(c['builders'])
    print "# schedulers: ", len(c['schedulers'])
    assert(len(c['builders']) == 176)
    assert(len(c['schedulers']) == 239)
    # print [sc.name for sc in c['schedulers']]

test_easy_and_no_easy(c)
test_fail2ban_08_state(c)
test_regression(c)
